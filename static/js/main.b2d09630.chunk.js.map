{"version":3,"sources":["SortingAlgorithms/mergeSort.js","SortingAlgorithms/selectionSort.js","SortingAlgorithms/quickSort.js","SortingAlgorithms/heapSort.js","SortingVisualiser/SortingVisualiser.jsx","SortingAlgorithms/insertionSort.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","i","j","push","doMerge","getSelectionSortAnimations","n","minIdx","swap","selectionSort","tmp","getQuickSortAnimations","quickSort","A","fe","fg","index","pivot","pivotIdx","hoarePartition","getHeapSortAnimations","siftDown","buildHeap","active","heapSort","parent","child","isRunning","SortingVisualiser","props","AlgorithmInfoElement","React","createRef","state","this","reset_array","window","location","reload","min","max","array_size","parseInt","innerWidth","max_size","innerHeight","random","setState","toggleBtn","current","updateInfo","arrayBars","document","getElementsByClassName","barOneIdxStyle","style","setTimeout","barTwoIdxStyle","backgroundColor","barOneStyle","barTwoStyle","height","v","insertionSort","getInsertionSortAnimations","barOneIdx","barTwoIdx","color","newHeight","console","log","colour","barStyle","idArray","btn","getElementById","disabled","className","id","onClick","selection_sort","insertion_sort","merge_sort","heap_sort","quick_sort","map","value","idx","key","ref","Component","AlgorithmInfo","name","bestCase","avgCase","worstCase","spaceC","inPlace","stable","misc","Newname","NewBest","NewAvg","NewWorst","NewSpace","NewInPlace","NewStable","NewMisc","App","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b2d09630.chunk.js","sourcesContent":["/**\r\n * \r\n * Merge Sort Information\r\n * Time Complexiy: Θ(nlogn)\r\n * \r\n * Space Complexity: O(n)\r\n * In-place: No, requires O(n) auxiliary array + O(logn) stack space if using recursion\r\n * Stable: Yes, merge keeps relative order with additional book keeping, i.e. left side goes first\r\n */\r\n\r\nexport function getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    \r\n    return animations;\r\n  }\r\n  \r\n  function mergeSortHelper(\r\n    mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n  }\r\n  \r\n  function doMerge(\r\n    mainArray,\r\n    startIdx,\r\n    middleIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n    while (i <= middleIdx && j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, j]);\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n    while (i <= middleIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, i]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, i]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([j, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([j, j]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }","/**\r\n * \r\n * Selection Sort Information\r\n * Time Complexites:\r\n *      Best: Ω(n^2)\r\n *      Avg: Θ(n^2)\r\n *      Worst: O(n^2)\r\n * \r\n * Space Complexity: O(1)\r\n * In-place: Yes\r\n * Stable: Yes\r\n */\r\n\r\nexport function getSelectionSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n\r\n    selectionSort(array, array.length, animations);\r\n    return animations;\r\n}\r\n\r\n// Main processing function\r\nfunction selectionSort(array, n, animations){\r\n    for (let i = 0; i < n; i++){\r\n        var minIdx = i;\r\n\r\n        //Loop through all elements outside sorted range\r\n        for (let j = i+1; j < n; j++){\r\n            animations.push([\"comparison1\", j, minIdx, i]);\r\n            animations.push([\"comparison2\", j, minIdx, i]); // comparison2 ensure that color change goes back to default\r\n            if (array[j] < array[minIdx]){\r\n                //Update minimum\r\n                minIdx = j;\r\n            }\r\n        }\r\n        //Swap smallest element with end of sorted array\r\n        swap(array, i, minIdx, animations);\r\n    }\r\n\r\n}\r\n\r\n// Swap array element values\r\nfunction swap(array, i, j, animations){\r\n    animations.push([\"swap\", i, j, array[i], array[j]]);\r\n    let tmp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = tmp;\r\n}\r\n\r\n  ","/**\r\n * \r\n * Quick Sort (with Hoare Partitioning) Information\r\n * Time Complexites:\r\n *      Best: Ω(nlogn)\r\n *      Avg: Θ(nlogn)\r\n *      Worst: O(n^2)\r\n * \r\n * Space Complexity: O(1)\r\n * In-place: Yes, but still requires O(logn) memory for the stack\r\n * Stable: No, non-local swaps\r\n */\r\n\r\nexport function getQuickSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n\r\n    quickSort(array, 0, array.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\nfunction quickSort(A, fe, fg, animations){\r\n    if (fe >= fg) return;\r\n    animations.push([\"comparison1\", fe]);\r\n    let index = hoarePartition(A, fe, fg, animations);\r\n    animations.push([\"comparison2\", fe]);\r\n\r\n    quickSort(A, fe, index - 1, animations);\r\n    quickSort(A, index, fg, animations);\r\n}\r\n\r\n/*  Pivot chosen as first element so visually easier to read, despite\r\n    a random pivot being prefeable in practice\r\n*/\r\nfunction hoarePartition(A, fe, fg, animations){\r\n    let pivot = A[fe];\r\n    let pivotIdx = fe;\r\n    animations.push([\"comparison1\", fe]);\r\n    while(fe <= fg){\r\n        animations.push([\"comparison1\", pivotIdx]);\r\n        while(A[fe] < pivot && fe <= fg){\r\n            animations.push([\"comparison1\", fe]);\r\n            animations.push([\"comparison2\", fe]);\r\n            fe++;\r\n        }\r\n        while(A[fg] > pivot){\r\n            animations.push([\"comparison1\", fg]);\r\n            animations.push([\"comparison2\", fg]);\r\n            fg--;\r\n        } \r\n        if (fe <= fg){\r\n            swap(A, fe, fg, animations);\r\n            fe++;\r\n            fg--;\r\n        }\r\n    }\r\n    animations.push([\"comparison2\", fe]);\r\n    animations.push([\"comparison2\", pivotIdx]);\r\n    return fe;\r\n}\r\n\r\n// Swap array element values\r\nfunction swap(array, i, j, animations){\r\n    animations.push([\"comparison3\", i, j]);\r\n    animations.push([\"comparison4\", i, j]);\r\n    animations.push([\"swap\", i, j, array[i], array[j]]);\r\n\r\n    let tmp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = tmp;\r\n}\r\n","/**\r\n * \r\n * Heap Sort Information\r\n * Time Complexiy: Θ(nlogn)\r\n * \r\n * Space Complexity: O(1)\r\n * In-place: Yes, requires O(1) memory for auxiliary variables\r\n * Stable: No, non-local swaps\r\n */\r\n\r\nexport function getHeapSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n\r\n    heapSort(array, array.length, animations);\r\n    return animations;\r\n}\r\n\r\nfunction heapSort(array, n, animations){\r\n    buildHeap(array, n, animations); \r\n\r\n    /*  Continuously convert array to a heap and remove the top \r\n        element (largest) and place at end of unsorted region    */\r\n    for(let active = n - 1; active > 0; active--){\r\n        swap(array, 0, active, animations);\r\n        siftDown(array, 0, active, animations);\r\n    }\r\n}\r\n\r\nfunction buildHeap(array, n, animations){\r\n  for(let i = Math.floor(n/2); i >=0; i--){\r\n    siftDown(array, i, n, animations);\r\n  }\r\n}\r\n\r\nfunction siftDown(array, parent, n, animations){\r\n  let child = 2 * parent + 1;\r\n  if (child < n){\r\n      // There is at least one child to be checked\r\n    if (child + 1 < n && array[child] < array[child + 1]){\r\n        // The right child exists and is larger\r\n        animations.push([\"comparison\", child, child+1]);\r\n        animations.push([\"comparison\", child, child+1]);\r\n        child++;\r\n    }\r\n    if (array[parent] < array[child]){\r\n        // Parent is smaller than larger child\r\n        swap(array, parent, child, animations);\r\n        siftDown(array, child, n, animations);\r\n    }\r\n  }\r\n}\r\n\r\n// Swap array element values\r\nfunction swap(array, i, j, animations){\r\n    animations.push([\"comparison\", i, j]);\r\n    animations.push([\"comparison\", i, j]);\r\n    animations.push([\"swap\", i, j, array[i], array[j]]);\r\n    let tmp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = tmp;\r\n}\r\n\r\n","import React from 'react';\r\nimport './SortingVisualiser.css';\r\nimport {getMergeSortAnimations} from '../SortingAlgorithms/mergeSort.js';\r\nimport {getSelectionSortAnimations} from '../SortingAlgorithms/selectionSort.js';\r\nimport { getInsertionSortAnimations } from '../SortingAlgorithms/insertionSort';\r\nimport { getQuickSortAnimations } from '../SortingAlgorithms/quickSort';\r\nimport { getHeapSortAnimations } from '../SortingAlgorithms/heapSort';\r\n\r\nconst ANIMATION_SPEED_MS = 2;\r\nconst PRIMARY_COLOR = '#97C54E';\r\nconst SECONDARY_COLOR = 'white';\r\n\r\nconst MIN_VAL = 5;\r\n\r\n// Indicates whether an algorithm is currently being visualised\r\nlet isRunning = false;\r\n\r\nexport default class SortingVisualiser extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.AlgorithmInfoElement = React.createRef();\r\n\r\n        this.state = {\r\n            array: [],\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.reset_array();\r\n    }\r\n\r\n    reset_array(){\r\n        if (isRunning === true){\r\n            isRunning = false;\r\n            window.location.reload(false);\r\n        }\r\n\r\n        const array = [];\r\n        const array_size = parseInt((window.innerWidth)/20);\r\n        let max_size = parseInt(window.innerHeight - window.innerHeight * 0.25);\r\n        if (max_size > 730) max_size = 730;\r\n\r\n        for(let i = 0; i < array_size; i++){\r\n            array.push(random_int_from_interval(MIN_VAL, max_size));\r\n        }\r\n        this.setState({array});\r\n    }\r\n\r\n    // Functions controls animations for Selection Sort\r\n    selection_sort(){\r\n        this.toggleBtn();\r\n        isRunning = true;\r\n\r\n        // Update algorithm UI for selection sort info\r\n        this.AlgorithmInfoElement.current.updateInfo(\r\n            \"Selection Sort:\",\r\n            \"Ω(n^2)\",\r\n            \"Θ(n^2)\",\r\n            \"O(n^2)\",\r\n            \"O(1)\",\r\n            \"Yes, addition O(1) for auxiliary variables\",\r\n            \"Yes\",\r\n            \"Appropriate for small array sizes. Useful if minimizing swaps is desirable\"\r\n            );\r\n\r\n        const animations = getSelectionSortAnimations(this.state.array);\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        // Loop through animations\r\n        for (let i = 0; i < animations.length; i++){\r\n            const barOneIdxStyle = arrayBars[animations[i][1]].style;\r\n            if (animations[i][0] === \"comparison1\"){\r\n                // Visualise comparison\r\n                setTimeout(() => {\r\n                    const barTwoIdxStyle = arrayBars[animations[i][3]].style;\r\n                    barOneIdxStyle.backgroundColor = SECONDARY_COLOR;\r\n                    barTwoIdxStyle.backgroundColor = SECONDARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n                // Revert bars back to defualt colour\r\n            }else if (animations[i][0] === \"comparison2\"){\r\n                setTimeout(() => {\r\n                    // Don't revert back end or sorted array if it will not be changed in the next iteration\r\n                    if (i < animations.length){\r\n                        if (animations[i + 1][2] !== animations[i][2]){\r\n                            const barTwoIdxStyle = arrayBars[animations[i][3]].style;\r\n                            barTwoIdxStyle.backgroundColor = PRIMARY_COLOR;\r\n                        }\r\n                    }\r\n                    barOneIdxStyle.backgroundColor = PRIMARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }else{\r\n                // Revert colours and change the heights of bars\r\n                setTimeout(() => {\r\n                    const barOneStyle = arrayBars[animations[i][1]].style;\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n                    //Swap heights\r\n                    barOneStyle.height = `${animations[i][4]}px`;\r\n                    barTwoStyle.height = `${animations[i][3]}px`;\r\n\r\n                    barOneStyle.backgroundColor = PRIMARY_COLOR;\r\n                    barTwoStyle.backgroundColor = PRIMARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n\r\n            // Re-enable the buttons once last animation is processed\r\n            if (i === animations.length - 1){\r\n                setTimeout(() => {\r\n                    this.toggleBtn();\r\n                    isRunning =  false;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Functions controls animations for Insertion Sort\r\n    insertion_sort(){\r\n        this.toggleBtn();\r\n        isRunning = true;\r\n\r\n        // Update algorithm UI for insertion sort info\r\n        this.AlgorithmInfoElement.current.updateInfo(\r\n            \"Insertion Sort:\",\r\n            \"Ω(n)\",\r\n            \"Θ(n^2)\",\r\n            \"O(n^2)\",\r\n            \"O(1)\",\r\n            \"Yes, may need additional O(1) memory\",\r\n            \"Yes, local adjacent swaps ensure stability\",\r\n            \"Good choice when data is almost sorted. Can be made slightly faster using a min sentinel.\"\r\n            );\r\n\r\n        const animations = getInsertionSortAnimations(this.state.array);\r\n        const arrayBars = document.getElementsByClassName('array-bar');  \r\n\r\n        // Loop through animations\r\n        for (let i = 0; i < animations.length; i++){\r\n            const barOneStyle = arrayBars[animations[i][1]].style;\r\n\r\n            // Change selected div colour to visualise that it is being used in a comparison\r\n            if (animations[i][0] === \"comparison1\"){\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = SECONDARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n\r\n            // Reset div colour to defualt as it is no longer being compared\r\n            }else if (animations[i][0] === \"comparison2\"){\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = PRIMARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            // Change bar heights to visualise swap\r\n            }else{\r\n                setTimeout(() => {\r\n                    barOneStyle.height = `${animations[i][2]}px`;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n\r\n            // Re-enable the buttons once last animation is processed\r\n            if (i === animations.length - 1){\r\n                setTimeout(() => {\r\n                    this.toggleBtn();                   \r\n                    isRunning =  false;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // Functions controls animations for Merge Sort\r\n    merge_sort(){\r\n        this.toggleBtn();\r\n        isRunning = true;\r\n\r\n        // Update algorithm UI for merge sort info\r\n        this.AlgorithmInfoElement.current.updateInfo(\r\n            \"Merge Sort:\",\r\n            \"Ω(nlogn)\",\r\n            \"Θ(nlogn)\",\r\n            \"O(nlogn)\",\r\n            \"O(n)\",\r\n            \"No, requires O(n) auxiliary array + O(logn) stack space if using recursion\",\r\n            \"Yes, merge keeps relative order with additional book keeping, i.e. left side goes first\",\r\n            \"Is an excellent choice if stability is required and extra memory cost is low. Guaranteed Θ(nlogn), highly parallelisable, Multiway Mergesort; excellent for secondary memory\"\r\n        );\r\n\r\n        const animations = getMergeSortAnimations(this.state.array);\r\n        \r\n        // Process array of animations\r\n        for (let i = 0; i < animations.length; i++) {\r\n          const arrayBars = document.getElementsByClassName('array-bar');\r\n          const isColorChange = i % 3 !== 2;\r\n\r\n          // Change div color depending on position in triplet, we know we have a colour change for the first two animations in a triplet\r\n          if (isColorChange) {\r\n            const [barOneIdx, barTwoIdx] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIdx].style;\r\n            const barTwoStyle = arrayBars[barTwoIdx].style;\r\n            const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n            setTimeout(() => {\r\n              barOneStyle.backgroundColor = color;\r\n              barTwoStyle.backgroundColor = color;\r\n            }, i * ANIMATION_SPEED_MS);\r\n          } else {\r\n            // Swap bar heights  \r\n            setTimeout(() => {\r\n              const [barOneIdx, newHeight] = animations[i];\r\n              const barOneStyle = arrayBars[barOneIdx].style;\r\n              barOneStyle.height = `${newHeight}px`;\r\n            }, i * ANIMATION_SPEED_MS);\r\n          }\r\n\r\n            // Re-enable the buttons once last animation is processed\r\n            if (i === animations.length - 1){\r\n                setTimeout(() => {\r\n                    this.toggleBtn();\r\n                    isRunning =  false;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function controls animations for Heap Sort\r\n    heap_sort(){\r\n        this.toggleBtn();\r\n        isRunning = true;\r\n\r\n        // Update algorithm UI for heap sort info\r\n        this.AlgorithmInfoElement.current.updateInfo(\r\n            \"Heap Sort:\",\r\n            \"Ω(nlogn)\",\r\n            \"Θ(nlogn)\",\r\n            \"O(nlogn)\",\r\n            \"O(1)\",\r\n            \"Yes, only additional O(1) memory for auxiliary variables\",\r\n            \"No, non-local swaps break stability\",\r\n            \"Best choice when low memory footprint is required and guaranteed Θ(nlogn) performance is needed, i.e security reasons\"\r\n        );\r\n        \r\n        const animations = getHeapSortAnimations(this.state.array);\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        // Process array of animations\r\n        console.log(animations.length);\r\n        for(let i = 0; i < animations.length; i++){\r\n            // Toggle between div colour depending on current background colour \r\n            if (animations[i][0] === \"comparison\"){\r\n                setTimeout(() => {\r\n                    const barOneStyle = arrayBars[animations[i][1]].style;\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n\r\n                    let colour;\r\n                    barOneStyle.backgroundColor === SECONDARY_COLOR ? colour = PRIMARY_COLOR : colour = SECONDARY_COLOR;\r\n\r\n                    barOneStyle.backgroundColor = colour;\r\n                    barTwoStyle.backgroundColor = colour;\r\n\r\n                  }, i * ANIMATION_SPEED_MS);\r\n            }else{\r\n                // Swaps heights of two bars\r\n                setTimeout(() => {\r\n                    const barOneStyle = arrayBars[animations[i][1]].style;\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n    \r\n                    barOneStyle.height = `${animations[i][4]}px`;\r\n                    barTwoStyle.height = `${animations[i][3]}px`;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n\r\n            // Re-enable the buttons once last animation is processed\r\n            if (i === animations.length - 1){\r\n                setTimeout(() => {\r\n                    this.toggleBtn();\r\n                    isRunning =  false;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function controls animations for Quick Sort (Hoare Partitioning)\r\n    quick_sort(){\r\n        this.toggleBtn();\r\n        isRunning = true;\r\n\r\n        // Update algorithm UI for quick sort info\r\n        this.AlgorithmInfoElement.current.updateInfo(\r\n        \"Quick Sort:\",\r\n        \"Ω(nlogn)\",\r\n        \"Θ(nlogn)\",\r\n        \"O(n^2)\",\r\n        \"O(logn)\",\r\n        \"Yes, but still requires O(logn) memory for the stack\",\r\n        \"No, non-local swaps break stability\",\r\n        \"Fastest sorting algorithm in most cases. Is the algorithm of choice when speed matters and stability is not required. In practice it is best to choose the pivot at random to avoid worst case and potential attacks\"\r\n        );\r\n\r\n        // Process array of animations\r\n        const animations = getQuickSortAnimations(this.state.array);\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n        for(let i = 0; i < animations.length; i++){\r\n            const barStyle = arrayBars[animations[i][1]].style;\r\n            if (animations[i][0] === \"comparison1\"){\r\n                // Highlight selected div\r\n                setTimeout(() => {\r\n                    barStyle.backgroundColor = SECONDARY_COLOR;\r\n                  }, i * ANIMATION_SPEED_MS);\r\n            }else if (animations[i][0] === \"comparison2\"){\r\n                // Revert div back to defualt colour\r\n                setTimeout(() => {\r\n                    barStyle.backgroundColor = PRIMARY_COLOR;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }else if (animations[i][0] === \"comparison3\"){\r\n                // Highlight two divs at the same time\r\n                setTimeout(() => {\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n                    barStyle.backgroundColor = SECONDARY_COLOR;\r\n                    barTwoStyle.backgroundColor = SECONDARY_COLOR;                \r\n                }, i * ANIMATION_SPEED_MS);\r\n            }else if (animations[i][0] === \"comparison4\"){\r\n                // Revert two divs to defualt colour at the same time\r\n                setTimeout(() => {\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n                    barStyle.backgroundColor = PRIMARY_COLOR;\r\n                    barTwoStyle.backgroundColor = PRIMARY_COLOR;             \r\n                }, i * ANIMATION_SPEED_MS);\r\n            }else{\r\n                // Swaps heights of two bars\r\n                setTimeout(() => {\r\n                    barStyle.height = `${animations[i][4]}px`;\r\n                    const barTwoStyle = arrayBars[animations[i][2]].style;\r\n                    barTwoStyle.height = `${animations[i][3]}px`;                              \r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n            \r\n            // Re-enable the buttons once last animation is processed\r\n            if (i === animations.length - 1){\r\n                setTimeout(() => {\r\n                    this.toggleBtn();\r\n                    isRunning = false;\r\n                }, i * ANIMATION_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Re-enable button interactivity once animations are finished\r\n    toggleBtn(){\r\n        const idArray = [\"selectionSortBtn\", \"insertionSortBtn\", \"mergeSortBtn\", \"heapSortBtn\", \"quickSortBtn\"];\r\n        for(let i = 0; i < idArray.length; i++){\r\n            let btn =  document.getElementById(idArray[i]);\r\n            btn.disabled = !btn.disabled;   \r\n        }\r\n    }\r\n\r\n    render(){\r\n        const {array} = this.state;\r\n        return(\r\n            <>\r\n            <div className=\"header\">\r\n                <h1>Sorting Algorithm Visualiser</h1>\r\n                <p>Created by Jason Rising</p>\r\n                <div className=\"nav-bar\">\r\n                    <button id=\"resetBtn\" onClick={() => this.reset_array()}>Randomise Array</button>\r\n                    <button id=\"selectionSortBtn\" onClick={() => this.selection_sort()}>Selection Sort</button>\r\n                    <button id=\"insertionSortBtn\" onClick={() => this.insertion_sort()}>Insertion Sort</button>\r\n                    <button id=\"mergeSortBtn\" onClick={() => this.merge_sort()}>Merge Sort</button>\r\n                    <button id=\"heapSortBtn\" onClick={() => this.heap_sort()}>Heap Sort</button>\r\n                    <button id=\"quickSortBtn\" onClick={() => this.quick_sort()}>Quick Sort</button>\r\n                </div>\r\n            </div>\r\n            <div className=\"array-container\">\r\n                {array.map((value, idx) => (\r\n                    <div className=\"array-bar\" \r\n                    key={idx} \r\n                    style={{height: `${value}px`}}>\r\n                    </div>\r\n                ))}\r\n            </div> \r\n            <AlgorithmInfo ref={this.AlgorithmInfoElement}/>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\n// Component handles displaying of different algorithm infomation\r\nclass AlgorithmInfo extends React.Component {\r\n    state = {\r\n        name: \"No Algorithm Selected\",\r\n        bestCase: \"\",\r\n        avgCase: \"\",\r\n        worstCase: \"\",\r\n\r\n        spaceC: \"\",\r\n\r\n        inPlace: \"\",\r\n        stable: \"\",\r\n        misc: \"\",\r\n    };\r\n\r\n    // Updates various information based on passed information\r\n    updateInfo(Newname, NewBest, NewAvg, NewWorst, NewSpace, NewInPlace, NewStable, NewMisc){\r\n        this.setState({\r\n            name: Newname,\r\n            bestCase: NewBest,\r\n            avgCase: NewAvg,\r\n            worstCase: NewWorst,\r\n            spaceC: NewSpace,\r\n            inPlace: NewInPlace,\r\n            stable: NewStable,\r\n            misc: NewMisc\r\n        });\r\n    }\r\n\r\n\r\n    render(){\r\n        return(\r\n            <div className='info-container'>\r\n                <h1>{this.state.name}</h1>\r\n                <div className='grid'>\r\n                    <div>\r\n                        <h1>Time Complexity</h1>\r\n                        <p><strong>Best Case: </strong>{this.state.bestCase}</p>\r\n                        <p><strong>Average Case: </strong>{this.state.avgCase}</p>\r\n                        <p><strong>Worst Case: </strong>{this.state.worstCase}</p>\r\n                    </div>\r\n                    <div>\r\n                        <h1>Space Complexity</h1>\r\n                        <p><strong>Worst Case: </strong>{this.state.spaceC}</p>\r\n                    </div>\r\n                    <div>\r\n                        <h1>General Info</h1>\r\n                        <p><strong>In-place: </strong>{this.state.inPlace}</p>\r\n                        <p><strong>Stable: </strong>{this.state.stable}</p>\r\n                        <p><strong>Misc: </strong>{this.state.misc}</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );  \r\n    }\r\n}\r\n\r\n// Returns an int between a set min and max interval\r\nfunction random_int_from_interval(min, max){\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n","/**\r\n * \r\n * Insertion Sort Information\r\n * Time Complexites:\r\n *      Best: Ω(n)\r\n *      Avg: Θ(n^2)\r\n *      Worst: O(n^2)\r\n * \r\n * Space Complexity: O(1)\r\n * In-place: Yes\r\n * Stable: Yes\r\n */\r\n\r\nexport function getInsertionSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n\r\n    insertionSort(array, array.length, animations);\r\n    return animations;\r\n}\r\n\r\n// Main processing function\r\nfunction insertionSort(array, n, animations){\r\n    for (let i = 0; i < n; i++){\r\n        let v = array[i];\r\n        let j = i - 1;\r\n\r\n        animations.push([\"comparison1\", i]);\r\n\r\n        while(j >= 0 && array[j] > v){\r\n            animations.push([\"comparison1\", j]);\r\n            array[j + 1] = array[j];\r\n            animations.push([\"changeHeight\", j + 1, array[j]]);\r\n            animations.push([\"comparison2\", j]); \r\n            j--;\r\n        }\r\n        array[j + 1] = v;\r\n        animations.push([\"changeHeight\", j + 1, v]);\r\n        animations.push([\"comparison2\", i]);\r\n    }\r\n}\r\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualiser/SortingVisualiser';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}